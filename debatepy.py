import streamlit as st
from debate_manager import DebateManager
from debate_system import DebateAgent
import asyncio
import json
import yaml
from datetime import datetime
from debate_logger import DebateLogger
import re

def load_config():
    try:
        with open('config.yaml', 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        print(f"Error loading config: {e}")
        return {}

class StreamlitDebateManager:
    def __init__(self, selected_topic=None, total_rounds=20):
        self.config = load_config()
        self.debate_prompt = self.config.get('debate_prompt', '')
        self.total_rounds = total_rounds
        self.conclusion_phase = False # This is internal to manager logic
        
        agent_configs = self.config.get('agents', {})
        self.agent_us = DebateAgent(
            name=agent_configs['openai']['name'],
            personality=agent_configs['openai']['personality'],
            agent_config_key='openai',
            config=self.config
        )
        self.agent_china = DebateAgent(
            name=agent_configs['deepseek']['name'],
            personality=agent_configs['deepseek']['personality'],
            agent_config_key='deepseek',
            config=self.config
        )
        self.agent_eu = DebateAgent(
            name=agent_configs['european_union']['name'],
            personality=agent_configs['european_union']['personality'],
            agent_config_key='european_union',
            config=self.config
        )
        self.agents = [self.agent_us, self.agent_china, self.agent_eu]
        self.logger = DebateLogger()
        
        topics_from_config = self.config.get('topics', [])
        all_topic_names = [t.get('name') for t in topics_from_config if t.get('name')]
        if selected_topic and selected_topic in all_topic_names:
            topic = selected_topic
        elif all_topic_names:
            import random
            topic = random.choice(all_topic_names)
            self.logger.log_event("TopicWarning", f"Provided selected_topic '{selected_topic}' was invalid or None. Randomly selected: {topic}")
        else:
            topic = "General AI Governance Discussion"
            self.logger.log_event("TopicWarning", "No topics found in config.yaml. Defaulting to generic topic.")
        
        self.debate = DebateManager(agents=self.agents, topic=topic)
        self.logger.log_event("Deliberation Initialized", f"Topic: {self.debate.topic}, Rounds: {self.total_rounds}")
        # self.current_round = 0 # This was for StreamlitDebateManager's own tracking, DebateManager has its own
        self.conclusion_order = [self.agent_us.name, self.agent_eu.name, self.agent_china.name]
        self.current_conclusion_index = 0 # Index for iterating through conclusion_order

    async def get_next_response(self):
        # This method now primarily fetches responses. Phase transition logic is mostly UI-driven.
        if self.conclusion_phase:
            if self.current_conclusion_index >= len(self.conclusion_order):
                return None # All conclusions presented
            agent_name_to_conclude = self.conclusion_order[self.current_conclusion_index]
            current_agent_object = next((agent for agent in self.agents if agent.name == agent_name_to_conclude), None)
            if not current_agent_object:
                self.logger.log_event("Error", f"Agent {agent_name_to_conclude} not found for conclusion.")
                # self.current_conclusion_index += 1 # UI will advance this upon successful retrieval or skip
                return {"error": f"Agent {agent_name_to_conclude} not found."}
            
            context = self._build_conclusion_context()
            conclusion_message = await current_agent_object.generate_conclusion(context=context)
            self.logger.log_event(f"Conclusion from {agent_name_to_conclude}", f"Generated by LLM.")
            return {"agent_name": agent_name_to_conclude, "message": conclusion_message}
        else: # Deliberation phase
            # Check if it's time to transition (UI should prevent calling this if rounds are done)
            if self.debate.current_turn >= self.total_rounds:
                 return self._prepare_conclusion_transition() # Signal to UI to switch phase

            round_info_prompt = self.debate_prompt.replace("{round_number}", str(self.debate.current_turn + 1))\
                                               .replace("{total_rounds}", str(self.total_rounds))
            if not self.debate.conversation_history:
                response = await self.debate.start_debate(debate_prompt=round_info_prompt)
                self.logger.log_event("Deliberation Started", f"Round 1 of {self.total_rounds}")
            else:
                response = await self.debate.next_turn(debate_prompt=round_info_prompt)
                self.logger.log_event(f"Deliberation Round {self.debate.current_turn}", f"Agent: {self.debate.get_current_agent_name()}")
            return response
    
    def _prepare_conclusion_transition(self):
        return f"After {self.total_rounds} rounds of deliberation on {self.debate.topic}, each representative will now present their final position."
    
    def _build_conclusion_context(self):
        if not self.debate.conversation_history:
            return f"Topic: {self.debate.topic}"
        return "\n".join([f"{msg['agent']}: {msg['message']}" for msg in self.debate.conversation_history[-10:]])

def format_message_with_round(message, round_num=None):
    # This function might become less relevant if messages are self-contained with round info
    if round_num:
        return f"**Round {round_num}**\n\n{message}"
    return message

def main():
    st.set_page_config(page_title="AI Futures Deliberation", layout="wide")
    st.title("üåê AI Futures Deliberation")
    st.markdown("User-controlled deliberation on AI governance.")

    # --- Sidebar for settings --- 
    with st.sidebar:
        st.subheader("Deliberation Settings")
        config = load_config()
        topics_from_config = config.get('topics', [])
        topic_options = [t.get('name') for t in topics_from_config if t.get('name')] or ["Default Topic - Check config.yaml"]
        
        # Use unique keys for sidebar widgets to avoid conflict if main area also has them
        selected_topic_sb = st.selectbox("Select Deliberation Topic", options=topic_options, index=0, key="sb_topic")
        num_rounds_sb = st.slider("Deliberation Rounds", min_value=1, max_value=30, value=10, key="sb_rounds")

        if st.button("üîÑ Configure New Deliberation", use_container_width=True, key="configure_new"):
            st.session_state.selected_topic = selected_topic_sb
            st.session_state.num_rounds = num_rounds_sb
            st.session_state.debate_initialized = False # Mark for re-initialization
            st.session_state.conversation = []
            st.session_state.turn_count = 0 
            st.session_state.conclusions = []
            st.session_state.conclusion_phase_active = False 
            if 'debate_manager' in st.session_state: 
                del st.session_state.debate_manager # Remove old manager
            st.session_state.current_log_message = "New settings loaded. Click 'Initialize Deliberation' to start."
            st.rerun()

        # Export button - active only if debate has been initialized and run at least one turn
        if st.session_state.get('debate_initialized', False) and st.session_state.get('turn_count', 0) > 0:
            if st.button("üìù Export Deliberation", use_container_width=True, key="export_deliberation"):
                if 'debate_manager' in st.session_state:
                    export_data = {
                        "topic": st.session_state.debate_manager.debate.topic,
                        "total_rounds": st.session_state.debate_manager.total_rounds,
                        "deliberation": st.session_state.get('conversation', []),
                        "conclusions": st.session_state.get("conclusions", [])
                    }
                    st.download_button(
                        label="Download Transcript (JSON)",
                        data=json.dumps(export_data, indent=2, ensure_ascii=False),
                        file_name=f"deliberation_{st.session_state.debate_manager.debate.topic.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                        mime="application/json"
                    )
                else:
                    st.warning("Debate manager not found for export.")

    # --- Initialize State Variables (if they don't exist on first run or after full clear) --- 
    if 'selected_topic' not in st.session_state:
        st.session_state.selected_topic = topic_options[0]
    if 'num_rounds' not in st.session_state:
        st.session_state.num_rounds = 10 # Default value
    if 'debate_initialized' not in st.session_state:
        st.session_state.debate_initialized = False
    if 'conversation' not in st.session_state:
        st.session_state.conversation = []
    if 'turn_count' not in st.session_state:
        st.session_state.turn_count = 0
    if 'conclusions' not in st.session_state:
        st.session_state.conclusions = []
    if 'current_log_message' not in st.session_state:
        st.session_state.current_log_message = "Welcome! Configure settings and initialize a new deliberation."
    if 'conclusion_phase_active' not in st.session_state:
        st.session_state.conclusion_phase_active = False

    # --- Main Area --- 
    if not st.session_state.debate_initialized:
        st.markdown("### Setup Deliberation")
        st.write(f"Topic: **{st.session_state.selected_topic}**")
        st.write(f"Rounds: **{st.session_state.num_rounds}**")
        if st.button("üöÄ Initialize Deliberation with Above Settings", key="init_debate_main"):
            st.session_state.debate_manager = StreamlitDebateManager(st.session_state.selected_topic, st.session_state.num_rounds)
            st.session_state.debate_initialized = True
            st.session_state.conversation = [] # Ensure clean slate
            st.session_state.turn_count = 0
            st.session_state.conclusions = []
            st.session_state.conclusion_phase_active = False
            st.session_state.current_log_message = f"Deliberation initialized: '{st.session_state.selected_topic}' ({st.session_state.num_rounds} rounds). Ready for first turn."
            st.rerun()
        st.info(st.session_state.current_log_message)
        return # Stop further rendering until initialized

    # If initialized, proceed to show debate interface
    # Ensure debate_manager is loaded from session state for subsequent interactions
    debate_manager = st.session_state.debate_manager 
    agent_us_name = debate_manager.agent_us.name
    agent_china_name = debate_manager.agent_china.name
    agent_eu_name = debate_manager.agent_eu.name
    topic = debate_manager.debate.topic # Get actual topic from the initialized manager
    total_deliberation_rounds = debate_manager.total_rounds

    st.markdown(f"### Deliberation Topic: {topic}")
    participants_display = f"üá∫üá∏ **{agent_us_name}** | üá®üá≥ **{agent_china_name}** | üá™üá∫ **{agent_eu_name}**"
    st.markdown(participants_display)
    st.info(st.session_state.current_log_message)

    # --- Control Panel --- 
    st.markdown("### Control Panel")
    # control_cols = st.columns(1) # Use a single column for simplicity first

    # Button to advance deliberation turns
    if not st.session_state.conclusion_phase_active and st.session_state.turn_count < total_deliberation_rounds:
        if st.button("‚ñ∂Ô∏è Next Deliberation Turn", use_container_width=True, key="next_delib_turn"):
            with st.spinner(f"Generating Round {debate_manager.debate.current_turn + 1}..."):
                response = asyncio.run(debate_manager.get_next_response())
                if isinstance(response, str) and not response.startswith("After "): # Regular deliberation response
                    current_speaker = debate_manager.debate.get_current_agent_name()
                    st.session_state.conversation.append({
                        "agent": current_speaker,
                        "message": response,
                        "round": debate_manager.debate.current_turn, 
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })
                    st.session_state.turn_count = debate_manager.debate.current_turn 
                    st.session_state.current_log_message = f"Round {st.session_state.turn_count} by {current_speaker} recorded."
                elif isinstance(response, str) and response.startswith("After "): # Transition message received prematurely
                    st.session_state.conclusion_phase_active = True
                    debate_manager.conclusion_phase = True # Sync manager state
                    debate_manager.current_conclusion_index = 0
                    st.session_state.current_log_message = response
                    st.success(response)
                else:
                    st.session_state.current_log_message = "Error: Unexpected response during deliberation."
                    st.error(f"Unexpected response: {response}")
            st.rerun()

    # Button to proceed to conclusion phase
    elif not st.session_state.conclusion_phase_active and st.session_state.turn_count >= total_deliberation_rounds:
        if st.button("üèÅ Proceed to Conclusion Phase", use_container_width=True, key="proceed_to_concl"):
            transition_message = debate_manager._prepare_conclusion_transition()
            debate_manager.conclusion_phase = True # Ensure manager is in conclusion phase
            st.session_state.conclusion_phase_active = True
            debate_manager.current_conclusion_index = 0 # Reset index for starting conclusions
            st.session_state.current_log_message = transition_message
            st.success(transition_message)
            st.rerun()

    # Button to get next agent's conclusion
    elif st.session_state.conclusion_phase_active and debate_manager.current_conclusion_index < len(debate_manager.conclusion_order):
        next_conclusion_agent_name = debate_manager.conclusion_order[debate_manager.current_conclusion_index]
        if st.button(f"üìú Get {next_conclusion_agent_name}'s Conclusion", use_container_width=True, key=f"get_concl_{next_conclusion_agent_name.replace(' ', '_')}"):
            with st.spinner(f"Generating conclusion for {next_conclusion_agent_name}..."):
                # Ensure the manager knows it's in conclusion phase before calling get_next_response
                debate_manager.conclusion_phase = True 
                response_data = asyncio.run(debate_manager.get_next_response())
                if response_data and isinstance(response_data, dict) and "agent_name" in response_data:
                    st.session_state.conclusions.append({
                        "agent_name": response_data["agent_name"],
                        "message": response_data["message"],
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })
                    st.session_state.current_log_message = f"Conclusion from {response_data['agent_name']} generated."
                    debate_manager.current_conclusion_index += 1 # Advance index AFTER successful retrieval
                elif response_data is None: # All conclusions might be done
                    st.session_state.current_log_message = "All conclusions appear to be presented."
                elif response_data and isinstance(response_data, dict) and "error" in response_data:
                    st.session_state.current_log_message = f"Error: {response_data['error']}"
                    st.error(response_data['error'])
                else:
                    st.session_state.current_log_message = f"Error or unexpected data getting conclusion for {next_conclusion_agent_name}."
                    st.error(f"Unexpected response data: {response_data}")
            st.rerun()
    else:
        if st.session_state.get('debate_initialized', False):
             st.success(f"Deliberation on '{topic}' ({total_deliberation_rounds} rounds) and all conclusions complete!")
             st.session_state.current_log_message = "Debate fully concluded."

    # --- Display Area (Progress, Transcript, Conclusions) --- 
    st.markdown("---Deliberation Progress---")
    current_progress_turn = st.session_state.get('turn_count', 0)
    if st.session_state.conclusion_phase_active:
        conclusions_presented = debate_manager.current_conclusion_index
        total_conclusions = len(debate_manager.conclusion_order)
        st.success(f"Deliberation Complete ({current_progress_turn}/{total_deliberation_rounds} rounds). Presenting Conclusions: {conclusions_presented}/{total_conclusions}")
    else:
        progress = min(current_progress_turn / total_deliberation_rounds, 1.0) if total_deliberation_rounds > 0 else 0
        st.progress(progress)
        st.caption(f"Deliberation Progress: Round {current_progress_turn} of {total_deliberation_rounds}")

    if st.session_state.get("conversation"):
        st.markdown("### Deliberation Transcript")
        for i, message_data in enumerate(st.session_state.conversation):
            round_num = message_data.get("round", i + 1)
            agent_name = message_data["agent"]
            avatar = "üá∫üá∏" 
            if agent_name == agent_china_name: avatar = "üá®üá≥"
            elif agent_name == agent_eu_name: avatar = "üá™üá∫"
            with st.chat_message(agent_name, avatar=avatar):
                st.markdown(f"**{agent_name} (Round {round_num})**")
                
                # Split message to separate document citations if present
                message_text = message_data["message"]
                doc_citations = ""
                
                if "_Sources referenced:_" in message_text:
                    parts = message_text.split("_Sources referenced:_")
                    message_text = parts[0].strip()
                    doc_citations = "_Sources referenced:_" + parts[1]
                
                # Display the main message
                st.markdown(message_text)
                
                # Display document citations with styling if present
                if doc_citations:
                    st.markdown(f"""
                    <div style="font-size: 0.8em; border-left: 3px solid #ccc; padding-left: 10px; margin-top: 10px; color: #555;">
                    {doc_citations}
                    </div>
                    """, unsafe_allow_html=True)
    
    if st.session_state.get("conclusions"):
        st.markdown("### Final Position Papers")
        for conclusion_data in st.session_state.conclusions:
            agent_name = conclusion_data["agent_name"]
            avatar = "üá∫üá∏"
            flag_text = "United States"
            if agent_name == agent_china_name: avatar, flag_text = "üá®üá≥", "People's Republic of China"
            elif agent_name == agent_eu_name: avatar, flag_text = "üá™üá∫", "European Union"
            with st.expander(f"{avatar} {flag_text}'s Final Position"):
                st.markdown(conclusion_data["message"])

if __name__ == "__main__":
    main()
